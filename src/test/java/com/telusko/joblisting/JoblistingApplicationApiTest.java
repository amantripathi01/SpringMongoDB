// ********RoostGPT********
/*
Test generated by RoostGPT for test aman5May using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=api_bd649fbc9c
ROOST_METHOD_SIG_HASH=api_eeb7f3b224

"""
  Scenario 1: Testing the successful creation of the Docket Bean

  Details:
    TestName: testSuccessfulDocketBeanCreation
    Description: This test is meant to check the successful creation of Docket bean using the 'api' method. It validates if the method returns a Docket object after execution.

  Execution:
    Arrange: Use any required data or mocks for Docket, DocumentationType.SWAGGER_2, RequestHandlerSelectors, and PathSelectors.
    Act: Invoke the api method.
    Assert: Use JUnit assertions to check if the returned object is an instance of Docket.
  Validation:
    The assertion verifies the successful creation of the Docket bean. The expected result is a Docket instance because that's the object the 'api' method is supposed to produce. This test is important for ensuring that the application will be able to generate API documentation using Swagger 2.

  Scenario 2: Validation of Swagger Documentation Type

  Details:
    TestName: testSwaggerDocumentationType
    Description: This test is meant to verify the documentation type set by the 'api' method, ensuring that it's SWAGGER_2.

  Execution:
    Arrange: Use required data or mocks for Docket and DocumentationType.SWAGGER_2.
    Act: Invoke the api method and retrieve the Docket object's documentation type.
    Assert: Use JUnit assertions to check if the documentation type is indeed SWAGGER_2.
  Validation:
    This assertion aims to validate the documentation type. The expected result is DocumentationType.SWAGGER_2 because that's what the 'api' method configures. This test is crucial for ensuring that the API documentation generated is compliant with Swagger 2 standards.

  Scenario 3: Validation of RequestHandlerSelectors

  Details:
    TestName: testRequestHandlerSelectors
    Description: This test is meant to verify that the 'api' method configures only APIs with RestController class annotation to be documented.

  Execution:
    Arrange: Use required data or mocks for Docket, RestController, and RequestHandlerSelectors.
    Act: Invoke the api method and review the APIs that are selected to be documented.
    Assert: Use JUnit assertions to confirm that only APIs with RestController class annotation are selected.
  Validation:
    This assertion ensures that APIs without RestController class annotation will not be documented. The significance of this test is to ensure that the documentation is correctly limited to REST style APIs.

  Scenario 4: Check for Default Response Messages

  Details:
    TestName: testDefaultResponseMessages
    Description: This test verifies if the default response messages are disabled in the created docket object as per the 'api' method configuration.

  Execution:
  Arrange: Mock the necessary classes and data.
  Act: Invoke the 'api' method and fetch the flags for default response messages of the returned Docket object.
  Assert: Use JUnit assertions to check if the default response messages are indeed disabled.
  Validation:
  This assertion verifies the flag disabling default response messages. The expected outcome should be 'false' as it is set in the 'api' method. This test is important to ensure that the API documentation does not generate default response messages.

"""
*/

// ********RoostGPT********

package com.telusko.joblisting;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.junit.Assert.*;
import org.mockito.InjectMocks;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.boot.test.context.SpringBootTest;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import static org.mockito.Mockito.*;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.RestController;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@RunWith(MockitoJUnitRunner.class)
@SpringBootTest
public class JoblistingApplicationApiTest {

	private Docket mockDocket;

	private RequestHandlerSelectors mockRequestHandlerSelectors;

	@InjectMocks
	public JoblistingApplicationApi joblistingApplicationApiUnderTest;

	@Before
	public void set_up() {
		mockDocket = mock(Docket.class);
		mockRequestHandlerSelectors = mock(RequestHandlerSelectors.class);
	}

	@Test
	public void testSuccessfulDocketBeanCreation() {
		Docket actualRes = joblistingApplicationApiUnderTest.api();
		assertNotNull(actualRes);
		assertTrue(actualRes instanceof Docket);
	}

	@Test
    public void testSwaggerDocumentationType() {
        when(mockDocket.getDocumentationType()).thenReturn(DocumentationType.SWAGGER_2);
        Docket actualRes = joblistingApplicationApiUnderTest.api();
        assertEquals(DocumentationType.SWAGGER_2, actualRes.getDocumentationType());
    }

	@Test
    public void testRequestHandlerSelectors() {
        when(mockDocket.getDocumentationType()).thenReturn(DocumentationType.SWAGGER_2);
        Docket actualRes = joblistingApplicationApiUnderTest.api();
        verify(mockDocket, times(1)).select();
    }

	@Test
    public void testDefaultResponseMessages() {
        when(mockDocket.getDocumentationType()).thenReturn(DocumentationType.SWAGGER_2);
        Docket actualRes = joblistingApplicationApiUnderTest.api();
        verify(mockDocket, times(1)).useDefaultResponseMessages(false);
    }

}
